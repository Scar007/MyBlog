---
title: 关于JS的面向对象总结
subtitle: faceObj
date: 2016-3-15
categories: JS
tags:
    - 面向对象
---

## 什么是面向对象：
对象由两部分构成：属性 和 方法；

## 面向对象的特点：

### 1.封装：对于相同功能的代码，放在一个函数中，以后再用到此功能，只需要调用即可，无需再重写；避免大量冗余代码；
 专业话说：低耦合，高内聚；
 
### 2.继承：子类继承父类原有的属性和方法；
 类：'Object','Function','Number','String','Array','RegExp','Date'.....
 具体的继承可看下述文章：[关于JS面向对象继承问题](https://scar007.github.io/2015/05/03/faceinherit/)
 
### 3.多态：重载和重写；
 重载：在JS中不存在严格意义上的重载；但是，JS中有类似重载的功能:同一个函数，传不同的参数，实现不同的功能；
 重写：子类可以重写父类的属性和方法；
 ```javascript
function getRandom(n,m){
n=Number(n);
m=Number(m);
if(isNaN(n) || isNaN(m)){
return Math.random();
}
if(n>m){
n=m+n;
m=n-m;
n=n-m;
}
return Math.round(Math.random()*(m-n)+n);
}
```
 
### 4.会学到的设计模式：单例模式，工厂模式，构造函数模式，原型模式；
.单例模式：把描述同一事物的属性和方法，放在同一个命名空间下，避免了变量名冲突的问题
 命名空间：浏览器开辟了一个堆内存，给他分配的名字person1就是命名空间
 单例模式本质：普通对象；
 
### 6.模块化开发：对于一个大型项目，项目组会分配给不同的工程师去开发（这些开发是同步进行的）；等所 有人开发完成，合在一起，整个项目就完成了；
 + 1)单例就是简单的模块化开发；
 + 2)可以实现本模块间的相互调用：this.属性名;
 + 3)可以实现模块之间的相互调用：模块名.属性名；
 
### 7.单例模式的优缺点：
优点：
   - 1）可以实现模块化开发
   - 2）避免了属性名相同，以及变量名相同的冲突问题；
缺点：传统的手工作业模式，开发效率低，并且造成大量冗余代码；
   > 解决措施：封装--工厂模式    
   
### 8.工厂模式的思想：
+ 1.引进一批原材料----1.var obj={}; var obj=new Object();我们自己创建一个空对象
+ 2.对原材料进行加工---2.给空对象添加一些私有的属性和方法；
+ 3.输出原材料---3.输出对象 return obj;
  > 工厂模式的本质：封装；
  
### 9.构造函数模式：--为了自定义一个类，并且可以创建一些实例；
 实例 instanceOf 类；==》返回的是 boolean值；
    
##### 构函数模式跟工厂模式的区别：
+ 1.在调用时候
    + 构造函数 new Person()；
    + 工厂模式 person();
+ 2.在函数体内的区别；
    + 构造函数：系统自动创建一个对象，等我们给对象加工完成后，系统自动输出该对象；
    + 工厂模式：手动创建对象，等我们给对象加工完成后，手动输出对象；
        > 缺点：对于相同的功能，却不相等；
        > 解决措施：prototype原型，把功能相同的代码，放在一个公共区间；


### 10.关于构造函数：
+ 1.构造函数中放的都是私有的属性和方法；
+ 2.就是实例和类在打交道；
+ 3.在创建一个实例的时候，如果不需要传参，小括号可以省略；
+ 4.构造函数this，永远指向当前实例；
+ 5.在构造函数中，实例只跟this.xxx有关系，跟变量没有任何关系；
+ 6.构造函数中，系统默认会为我们返回一个对象；如果我们手动返回的话：
    + 1)return 基本数据类型，不会造成任何影响；实例还有他的属性和方法；
    + 2)return 引用数据类型，会影响系统返回的对象，实例就没有他以前的属性和方法了； 所，不建议手动返回对象;
    
### 11.原型模式:原型 prototype
+ 1 当我们声明了一个函数(构造函数,类)的时候，天生自带了一个prototype的属性
    + 1 并且这prototype的值也是一个对象类型的
    + 2这个对象类型值也有一个天生自带的属性叫constructor并且这个性的值是函数(构造函数，类)本身
+ 2 这个类的实例也会有一个叫做__proto__的天生自带的属性,并且这个属性的值也是一个对象类型的这个值是这个实例所属类的原型.
+ 3 每一个引用类型都有一个天生自带的属性叫__proto__,所以说我们的prototype的值也有天生自一个__proto__的属性。并且这个属性的值也是一个对象类型，一直到我们的基类Object
+ 4 通过类的原型添加的属性和方法都是公有的，每个实例都会自带
+ 5 一个实例的方法在运行的时候，如果这个方法是自己私有的，那么就直接用，如果不是私有的，那通过__proto__去所属类的原型上去查找，如果还没有就通过原型的 __proto__一直查到基类的Object.果还没有报错，如果有就直接用了。我们把这种通过__proto__查找的机制叫做原型链.

### 12.原型模式的基础知识：重中之重
+ 1)每一个函数数据类型（类，普通函数）上都天生自带一个属性，叫做prototype（原型），它是一个对象；
+ 2)prototype这个原型上，天生自带一个属性，叫做constructor,指向当前所属的类； constructor：类；
+ 3)每个对象(实例，普通对象，prototype)上，都天生自带一个属性，叫做__proto__,他指向当前实例所属的类的原型；

### 13.Object.prototype:都放的公有的属性和方法
+ hasOwnProperty:判断attr这属性是否是这个对象上的私有属性；
+ isPrototypeOf：obj1是否在obj2的原型链上；
+ propertyIsEnumerable：是否可枚举的属性；

### 14
+ 每个类都是函数数据类型；
+ Object是对象数据类型的基类；

### 15
+ 构造函数模式：实例 和 类；
+ 原型模式：实例 ， 类， 原型；
+ 构造函数里：私有的属性和方法；
+ prototype上：公有的属性和方法；

### 16.原型链查找机制：比如要查找f1.x==>对象.属性名
+ 1)在自己的私有属性上查找，如果找到那么这个属性就是私有属性；
+ 2)如果没找到，通过__proto__去所属类的原型上进行查找，因为原型上放的都是公有的属性和方法，所以，如果找到，这个属性就是公有的；
+ 3)如果没找到，通过__proto__一层层往找，最终找到基类Object.prototye上，如果还没有，undefined！

### 17.重写：子类通过__proto__一级级往上去修改父类的属性和方法；这就是子类对父类的重写； 既然子类可以重写父类，系统为了防止子类通过__proto__去更改系统内置的属性和方法，所以在IE浏览器下，禁止我们使用__proto__;

### 18.继承：子类可以继承父类原有的属性和方法，但是当子类添加私有属性和方法的时候，不对父类造成影响；
+ 1)原型链继承：把父类的私有+公有的属性和方法，都作为子类公有的属性； 核心：不是把父类私有+公有的属性克隆一份一模一样的给子类的公有吧；他是通过__proto__建立和子类之间的原型链，当子类的实例需要使用父类的属性和方法的时候，可以通过__proto__一级级找上去使用；
+ 2)call继承：把父类私有的属性和方法给了子类私有的属性和方法； 
    > 核心思想：相当于把父类私有的属性和方法克隆了一份一模一样的给子类的私有属性；
+ 3)冒充对象继承：把父类公有的+私有的属性都作为了子类私有的属性；
+ 4)混合继承1：call继承+原型链继承 
    + call继承：把父类私有的作为自己私有的； 
    + 原型链继承：把父类私有+公有做为公有的； 
    + 问题：父类私有的，在子类私有+公有两个地方都存在；
+ 5)混合继承2：call继承+拷贝继承 
    + call继承：把父类私有的作为自己私有的； 
    + 拷贝继承：通过for in循环，把父类公有的属性和方法克隆了一份一模一样的给子类公有的；
+ 6)寄生式组合继承：
    + call继承：把父类私有的作为自己私有的；
    + Object.create()思想：
        + 1)创建一个空类；
        + 2)给空类的原型上添加了父类原型的地址；（相当于把父类原型上的公有属性和方法，给了空类原型上）
        + 3)子类的原型上添加空类的实例；（这样，子类就可以通过__proto__去找父类公有的属性和方法；但是不受父类私有属性的影响）

