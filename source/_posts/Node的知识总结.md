---
title: Node的知识总结
subtitle: node
date: 2017-1-22
categories: Node
tags:
    - node
---
## 一. 伪装URL-SEO
伪URL重写
+ 把一个动态页面的地址重写为静态页面的地址,为了方便网站的SEO优化
    + 真实地址:http://item.jd.com/detail.php?id=12261336038
    + 后缀名:php,aspx,asp,jsp....这些后缀名的地址都是动态地址,百度的搜索引擎是很难把这些地址中的内容进行收录的,所以需要伪装成静态的URL
    + 伪装地址:http://item.jd.com/12261336038.html

## 二. 浏览器解析机制
+ 开发者按照W3C规范编写代码
+ 浏览器开发商也会按照相同的规范开发浏览器
+ 当我们把代码交给浏览器的时候,浏览器使用GPU按照相关的规范绘制图形和页面
+ 各个浏览器拥有属于自己的内核和渲染引擎
    + webkit内核+V8引擎:chrome,移动端中APP的webView

## 三. NODE
+ node.js也是webkit内核的:node不是编程语言,它和浏览器类似只是一个工具(基于V8引擎解析的)
+ 如果我把node工具安装在服务器上,这样的话,我们就可以使用JS来编写服务器端的程序了,最后把编写好的JS代码运行在服务器的node环境下即可,node会帮我们进行解析和渲染->"JS页可以开发后台程序了"
+ 无阻塞的(异步的)I/O操作
+ 基于事件驱动,单线程异步
+ JS运行在客户端浏览器中,能否对客户端的本地文件进行I/O操作?
    + 不能,如果能的话将会对客户端的安全造成恶劣的影响;但是有些操作是可以进行:例如上传图片.但是这种情况都是需要当前用户手动操作的
+ JS运行在服务器的node环境中,是否可以对服务器进行I/O操作?
    + 可以
+ 模块
    + 内置模块
        + NODE环境天生为JS提供的
        + HTTP
            + 这个模块中提供了一系列的方法,让我们创建服务并且监听端口号已经接受客户端的请求信息,把需要的内容返回给客户端
            + 我们一般会把创建服务的代码放在server自定义模块中,而且会把这个js放在当前项目的根目录下,所以:如果server在哪,相当于当前的服务所负责的项目就是哪一个
                ```javascript
                      let http=require("http");
                      let server=http.createServer();//创建一个新的服务
                      //[callback]:不仅仅是服务创建成功,而且需要客户端向当前这个服务发生请求,回调函数才会被执行
                      server.listen(80,()=>{
                           console.log("server is success! listening on 80 port!");
                      }));//给创建的这个服务监听一个端口号 
                       //[port]:0-65535 //[callback]:当服务创建成功并且端口号也监听成功后执行的回调函数
                ```

            + 在服务器上,其他软件可能会占用80端口,导致80端口监听出错,所以服务器上不允许安装这些软件
            
            + 客户端如何向当前创建的这个服务发送请求
                + 在浏览器地址栏输入http://localhost:80/(服务在自己的电脑上,我们通过这种方式可以测试服务启动是否成功)
                + 在浏览器地址栏输入http://172.18.1.106:80/(这种方式不仅自己的电脑可以访问本地服务,别人的电脑如果和自己在同一个局域网下,也可以通过本机的ip访问到这个服务)
                    + 同一个局域网:
                        + 链接的是同一个WIFI(同一个网络)一般都是在同一个局域网下
                        + 子网掩码,默认网关,DNS都相同,IP地址雷士但是不相同,则在同一个局域网下,如果确定在同一个局域网下,但是互相访问不了,把电脑的防火墙关掉
    
    + 自定义模块
        + 自己封装的
        + 新建一个JS,就相当于在NODE环境中创建了一个自定义模块
        + 模块和模块之间是独立的,相互不会影响
        + 导入自定义模块
            + require("./temp.js")中的目录必须加"./".只有加了它,才会先从当前目录中进行查找,找到自定义的模块
            + 不写"./",是直接到node_modules中找安装的第三方模块或者是NODE自带的内置模块的
        ```javascript
        /*想把那个方法暴露到外面,供其他模块使用,需要做特殊的处理
        * module:NODE自带的模块管理对象
        * exports:是自带的把模块中方法导出的对象
        * */
        module.exports={
            fn:fn
        };
        ```
    + 第三方模块
        + 别人写好的,我们调取使用
            + 安装第三方模块
```javascript
npm install less --save-dev
```
            + 导入进来开始使用即可
     
    + 如何在js代码在NODE环境下执行?
        + 打开ws中,打开需要执行的JS文件,鼠标右键->run xxx.js (WS帮我们调取了NODE.exe然后把对应的JS执行的)
            + 在使用后手动在webstorm右上方的缓存进行清除
        + 在Terminal中使用node命令+文件名
             node 1.使用第三方模块.js
        + REPL命令(类似于浏览器的控制台,可以在这里输入JS代码执行) 
            
## 四. NPM
> NPM::模块或者包管理器,一般只要安装NODE就会自带NPM,在http://www.npmjs.com/这个网站下载

+ 我们可以把模块安装在全局下:npm install xxx -g,安装在全局下,不管是哪一个项目都可以基于命令来使用我们的模块进行相关的操作,但是也有一些自己的弊端:
    + 在项目中,不能通过require把模块导入进来,进行代码操作
    + 容易出现版本冲突,例如:我第一个项目用的是1.0版本,第二个用2.0版本,两个版本有一些区别,这样全局下到底是按照哪一个版本就无从规划了
    + 真实项目中,我们都会把模块安装在当前项目下,而不是全局,安装在当前项目中可以避免上述的两个问题,但是默认是不能使用命令操作了
+ 安装在当前项目中

    + 在当前项目根目录中生成一个package.json文件,这个文件是当前项目所需要模块的配置清单:npm init -y
        + 安装的目录一定要用英文
    + 我们以后再安装模块的时候,可以把安装的模块信息存储在这个配置清单中: npm install babel --save-dev
        + --save-dev:配置的是开发依赖模块信息
        + --save:配置的是生成依赖模块信息
    + 我们在当前项目中把需要安装的模块都存储在配置清单中,到下一个项目的时候,如果需要依赖的模块和这个项目类似,我们只需要把清单拷贝到第二个项目中,执行:npm install就会把需要的模块批量进行下载->"跑环境"
    + 查看当前模块的历史版本号:npm view xxx > xxx.txt
```javascript
 npm view babel-cli > babel-version.txt
```

    + 想要安装具体某一个版本的模块:npm install xxx@2.0.0 --save-dev
    + 把安装在当前项目中的模块配置可以执行的命令
```javascript
package.json
"script":{
    "babel":"babel ES6 -d ES5 -w"
}
```

        + 输入npm run "name"就好            
            
            
            