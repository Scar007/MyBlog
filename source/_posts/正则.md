---
title: 正则知识梳理
subtitle: reg
date: 2015-9-21
categories: 正则
tags:

---
一个用来处理字符串的规则，通过规则我们可以验证字符串是否匹配对应的格式(TEST)，也可以把正则匹配的结果在字符串中捕获到(EXEC)
## 正则由两部分组成：
+ 修饰符：i(ignoreCase忽略大写小匹配)、m(multilin匹配多行)、g(global全局匹配,解决正则捕获的懒惰性)
+ 元字符
    - 特殊元字符
        + \ ：转译字符
        + ^：以某一个元字符开头
        + $：以某一个元字符结尾
        + .：除了\n(换行符)以外的任意字符
        + \d：0-9之间的一个数字，等价于[0-9]
        + \D：和\d相反，除了0-9之间的任意字符，所有这类情况的(\s、\b…)都有一个大写情况，也都是和本身意思相反
        + \b：边界
        + \s：匹配任意一个空白字符(空格和制表符)
        + \w：匹配数字、字母、下划线中的任意一个，等价于[a-zA-Z0-9_]
        + [xyz]：x、y、z三者中的任意一个
        + [^xyz]：取反，除了x/y/x三者之外的任意字符
        + [a-z]：获取范围中的任意一个字符
        + [^a-z]：取反
        + |：或者
        + ()：分组
        + ?: ：只匹配不捕获
        + ?=：正向预查
        + ?!：负向预查
        …
    - 量词元字符
        + *：出现零到多次
        + +：出现一到多次
        + ?：出现零次或者一次
        + {n}：出现N次
        + {n,}：出现n到多次
        + {n,m}：出现n到m次
    - 普通元字符：在 / / 包含起来的，除了具有特殊意义的，其余的都是代表本身意思的普通元字符

## []的一些特殊情况：
+ 中括号中出现的字符，大部分都是代表本身的意思，例如：
```javascript   
/^[\d.]$/   //\d还是0-9之间一个数字，.不是任意字符只是一个小数点
```
+ 中括号中不识别多位数字，例如：/[1]$/ 1或者2-4或者0，三者中的一个

## ()的作用：
+ 改变优先级，栗如：
    - /^18|29$/ 匹配18、29、182、189、829、129、1829…都符合
    - /^(18|29)$/ 匹配18、29

+ 分组捕获：在正则每一次捕获的时候，除了可以把大正则匹配的结果捕获到，还可以把里面小分组匹配的内容捕获到，栗如：
```javascript
    var str = "my name is {0},my age is {1},my sex is {2}";
    var reg = /\{(\d)\}/g;
    reg.exec(str);  //['{0}',0]
    reg.exec(str);  //['{1}',1]
    reg.exec(str);  //['{2}',2]
    reg.exec(str);  //null
```
+ 分组引用：\1代表和第一个分组出现一模一样的内容,\2和第二个分组出现一模一样的内容…
```javascript
    var reg = /^([a-zA-Z])([a-zA-Z])\2([a-zA-Z])/;   //第三个字母需要和第二个字母一样
    // => book   food   foot   feed  ...都符合
```
+ 查找当前是第几个有效分组
```javascript   
    var reg = /^-?(\d|([1-9]\d+))(\.\d+)?$/;
    第一个分组：整数部分大个的
    第二个分组：整数部分里面的
    第三个分组：小数部分
    从左到右，按照“(”出现的顺序来计算是第几个分组

    var reg = /^-?(\d|(?:[1-9]\d+))(\.\d+)?$/
    /^(?:\w)(\w)\2(\w)$/.test('food')   //false
    /^(?:\w)(\w)\1(\w)$/.test('food')   //true

```

## 正则的两个方法: 检测test 捕获exec
> 注意语法和返回值,区分字符串中的search,match,replace方法的用法
```javascript   
//语法 :
    var reg = 6/^\d+$/g;
    reg.test('hello2017JavaScript');
    reg.exec('hello2017JavaScript');
```
+ 正则捕获的特点:
    + test、exec、match、replace、split…大部分字符串中支持正则的方法都可以实现正则的捕获
        - 1)懒惰性->
            <b>如何解决懒惰性? ->在正则的末尾加一个修饰符"g"</b>
            - global(g):全局匹配
            - ignoreCase(i):忽略大小写匹配
            - multiline(m):多行匹配
            - lastIndex:是正则每一次捕获在字符串中开始查找的位置，默认的值是0
        > 原理:加了全局修饰符g,正则每一次捕获结束后,我们的lastIndex的值都变为了最新的值,下一次捕获从最新的位置开始查找,这样就可以把所有需要捕获的内容都获取到了
        - 2)贪婪性 正则的每一次捕获都是按照匹配最长的结果捕获的
            例如:2符合正则 2015也符合正则,我们默认捕获的是2015
            ```javascript
            var reg = /\d+/g;   //->出现一到多个0-9之间的数字

            var str = "zhufeng2015peixun2016yangfan2017";
            console.log(reg.exec(str));//->["2015"...]
            ```
        <b>如何解决正则的贪婪性 ->在量词元字符后面添加一个?即可</b>
    
    <b>?在正则中有很多的作用:</b>
        + 放在一个普通的元字符后面代表出现0-1次 /\d?/ ->数字可能出现也可能不出现
        + 放在一个量词的元字符后面是取消捕获时候的贪婪性

        1)捕获到的内容是一个数组
        数组中的第一项是当前大正则捕获的内容
        index:捕获内容在字符串中开始的索引位置
        input:捕获的原始字符串
        ?的作用:①0或1次,②在量词修饰符后面加?是解决贪婪性,③?:reg是只匹配不捕获
        分组捕获()
+ 封装一个方法收集正则捕获到的结果
```javascript
    function capture(){
        var res = reg.exec(str);
        var ary = [];
        while (res){
            ary.push(res[0]);
            res = reg.exec(str)
        }
        return ary
    }
```
+ 字符串中可以使用正则的几个方法,区分与正则方法用法的差别
```javascript
    var str = "Hello2015JavaScript921",reg = /\d+/g;
    str.search(reg);  //返回第一次出现的索引，没有匹配到则返回-1
    str.match(reg); //返回第一数组，如果正则中没有分组，返回结果和reg.exec(str)的结果是一样的
    str.replace(reg,"1");
    str.replace(reg,function(){
        //arguments保存着正则每次捕获的结果
        //arguments[0]保存着大正则捕获的结果
        //arguments[1]是匹配到的内容的开始位置的索引
        //...
        return "1";  //返回什么就将捕获的内容替换成什么
    });
    str.split(/\d+/);  //返回数组
```
